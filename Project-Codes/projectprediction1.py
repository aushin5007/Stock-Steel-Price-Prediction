# -*- coding: utf-8 -*-
"""projectprediction1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LwCjOgxf6oa3WoNdIXG4rf5ziBL_vsPr
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error

# Load your dataset, assuming it's in a CSV file with columns 'Date' and 'Price'
data = pd.read_csv('/content/stock data/tatastock.csv')

# Convert 'Date' column to datetime type
data['Date'] = pd.to_datetime(data['Date'])

# Set 'Date' column as index
data.set_index('Date', inplace=True)

# Check the first few rows of the dataframe
print(data.head())

# Plot the time series data
plt.figure(figsize=(10, 6))
plt.plot(data.index, data['Price'])
plt.title('Steel Stock Price Over Time')
plt.xlabel('Date')
plt.ylabel('Price')
plt.show()

# Split data into train and test sets
train_size = int(len(data) * 0.8)
train, test = data.iloc[:train_size], data.iloc[train_size:]

# Define ARIMA model
model = ARIMA(train, order=(5,1,0)) # ARIMA(p,d,q) - You may need to tune these parameters
model_fit = model.fit()

# Summary of the model
print(model_fit.summary())

# Plot residual errors
residuals = pd.DataFrame(model_fit.resid)
residuals.plot()
plt.title('ARIMA Model Residuals')
plt.show()

# Predictions
history = [x for x in train['Price']]
predictions = list()
for t in range(len(test)):
    model = ARIMA(history, order=(5,1,0))
    model_fit = model.fit()
    output = model_fit.forecast()
    yhat = output[0]
    predictions.append(yhat)
    obs = test['Price'].iloc[t]
    history.append(obs)
    print('predicted=%f, expected=%f' % (yhat, obs))

# Calculate RMSE (Root Mean Squared Error)
error = mean_squared_error(test['Price'], predictions, squared=False)
print('Test RMSE: %.3f' % error)

# Plot predicted vs actual
plt.figure(figsize=(10, 6))
plt.plot(test.index, test['Price'], label='Actual')
plt.plot(test.index, predictions, color='red', label='Predicted')
plt.title('Steel Stock Price Prediction')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

from sklearn.metrics import accuracy_score

# Convert price changes to binary classes (up or down)
test['Price_Class'] = np.where(test['Price'].diff().shift(-1) > 0, 1, 0)

# Calculate binary predictions
binary_predictions = [1 if pred > 0 else 0 for pred in predictions]

# Calculate accuracy
accuracy = accuracy_score(test['Price_Class'], binary_predictions)
print("Accuracy:", accuracy)

from sklearn.metrics import f1_score

# Calculate the F1 score
f1 = f1_score(test['Price_Class'], binary_predictions)

# Print the F1 score
print("F1 Score:", f1)

data = pd.read_csv('/content/stock data/adanistock.csv')

# Convert 'Date' column to datetime type
data['Date'] = pd.to_datetime(data['Date'])

data.set_index('Date', inplace=True)

print(data.head())

# Plot the time series data
plt.figure(figsize=(10, 6))
plt.plot(data.index, data['Price'])
plt.title('Steel Stock Price Over Time')
plt.xlabel('Date')
plt.ylabel('Price')
plt.show()

# Split data into train and test sets
train_size = int(len(data) * 0.8)
train, test = data.iloc[:train_size], data.iloc[train_size:]

# Define ARIMA model
model = ARIMA(train, order=(5,1,0)) # ARIMA(p,d,q) - You may need to tune these parameters
model_fit = model.fit()

# Summary of the model
print(model_fit.summary())

# Plot residual errors
residuals = pd.DataFrame(model_fit.resid)
residuals.plot()
plt.title('ARIMA Model Residuals')
plt.show()

# Predictions
history = [x for x in train['Price']]
predictions = list()
for t in range(len(test)):
    model = ARIMA(history, order=(5,1,0))
    model_fit = model.fit()
    output = model_fit.forecast()
    yhat = output[0]
    predictions.append(yhat)
    obs = test['Price'].iloc[t]
    history.append(obs)
    print('predicted=%f, expected=%f' % (yhat, obs))

# Calculate RMSE (Root Mean Squared Error)
error = mean_squared_error(test['Price'], predictions, squared=False)
print('Test RMSE: %.3f' % error)

# Plot predicted vs actual
plt.figure(figsize=(10, 6))
plt.plot(test.index, test['Price'], label='Actual')
plt.plot(test.index, predictions, color='red', label='Predicted')
plt.title('Steel Stock Price Prediction')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

from sklearn.metrics import accuracy_score

# Convert price changes to binary classes (up or down)
test['Price_Class'] = np.where(test['Price'].diff().shift(-1) > 0, 1, 0)

# Calculate binary predictions
binary_predictions = [1 if pred > 0 else 0 for pred in predictions]

# Calculate accuracy
accuracy = accuracy_score(test['Price_Class'], binary_predictions)
print("Accuracy:", accuracy)

from sklearn.metrics import f1_score

# Calculate the F1 score
f1 = f1_score(test['Price_Class'], binary_predictions)

# Print the F1 score
print("F1 Score:", f1)

data = pd.read_csv('/content/stock data/jindalstock.csv')

# Convert 'Date' column to datetime type
data['Date'] = pd.to_datetime(data['Date'])

# Set 'Date' column as index
data.set_index('Date', inplace=True)

# Check the first few rows of the dataframe
print(data.head())

# Plot the time series data
plt.figure(figsize=(10, 6))
plt.plot(data.index, data['Price'])
plt.title('Steel Stock Price Over Time')
plt.xlabel('Date')
plt.ylabel('Price')
plt.show()

# Split data into train and test sets
train_size = int(len(data) * 0.8)
train, test = data.iloc[:train_size], data.iloc[train_size:]

# Define ARIMA model
model = ARIMA(train, order=(5,1,0)) # ARIMA(p,d,q) - You may need to tune these parameters
model_fit = model.fit()

# Summary of the model
print(model_fit.summary())

# Plot residual errors
residuals = pd.DataFrame(model_fit.resid)
residuals.plot()
plt.title('ARIMA Model Residuals')
plt.show()

# Predictions
history = [x for x in train['Price']]
predictions = list()
for t in range(len(test)):
    model = ARIMA(history, order=(5,1,0))
    model_fit = model.fit()
    output = model_fit.forecast()
    yhat = output[0]
    predictions.append(yhat)
    obs = test['Price'].iloc[t]
    history.append(obs)
    print('predicted=%f, expected=%f' % (yhat, obs))

# Calculate RMSE (Root Mean Squared Error)
error = mean_squared_error(test['Price'], predictions, squared=False)
print('Test RMSE: %.3f' % error)

# Plot predicted vs actual
plt.figure(figsize=(10, 6))
plt.plot(test.index, test['Price'], label='Actual')
plt.plot(test.index, predictions, color='red', label='Predicted')
plt.title('Steel Stock Price Prediction')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

from sklearn.metrics import accuracy_score

# Convert price changes to binary classes (up or down)
test['Price_Class'] = np.where(test['Price'].diff().shift(-1) > 0, 1, 0)

# Calculate binary predictions
binary_predictions = [1 if pred > 0 else 0 for pred in predictions]

# Calculate accuracy
accuracy = accuracy_score(test['Price_Class'], binary_predictions)
print("Accuracy:", accuracy)

from sklearn.metrics import f1_score

# Calculate the F1 score
f1 = f1_score(test['Price_Class'], binary_predictions)

# Print the F1 score
print("F1 Score:", f1)

data = pd.read_csv('/content/stock data/mukundstock.csv')

data['Date'] = pd.to_datetime(data['Date'])

data.set_index('Date', inplace=True)

print(data.head())

plt.figure(figsize=(10, 6))
plt.plot(data.index, data['Price'])
plt.title('Steel Stock Price Over Time')
plt.xlabel('Date')
plt.ylabel('Price')
plt.show()

train_size = int(len(data) * 0.8)
train, test = data.iloc[:train_size], data.iloc[train_size:]

model = ARIMA(train, order=(5,1,0)) # ARIMA(p,d,q) - You may need to tune these parameters
model_fit = model.fit()

print(model_fit.summary())

residuals = pd.DataFrame(model_fit.resid)
residuals.plot()
plt.title('ARIMA Model Residuals')
plt.show()

history = [x for x in train['Price']]
predictions = list()
for t in range(len(test)):
    model = ARIMA(history, order=(5,1,0))
    model_fit = model.fit()
    output = model_fit.forecast()
    yhat = output[0]
    predictions.append(yhat)
    obs = test['Price'].iloc[t]
    history.append(obs)
    print('predicted=%f, expected=%f' % (yhat, obs))

error = mean_squared_error(test['Price'], predictions, squared=False)
print('Test RMSE: %.3f' % error)

plt.figure(figsize=(10, 6))
plt.plot(test.index, test['Price'], label='Actual')
plt.plot(test.index, predictions, color='red', label='Predicted')
plt.title('Steel Stock Price Prediction')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

from sklearn.metrics import accuracy_score

# Convert price changes to binary classes (up or down)
test['Price_Class'] = np.where(test['Price'].diff().shift(-1) > 0, 1, 0)

# Calculate binary predictions
binary_predictions = [1 if pred > 0 else 0 for pred in predictions]

# Calculate accuracy
accuracy = accuracy_score(test['Price_Class'], binary_predictions)
print("Accuracy:", accuracy)

from sklearn.metrics import f1_score

# Calculate the F1 score
f1 = f1_score(test['Price_Class'], binary_predictions)

# Print the F1 score
print("F1 Score:", f1)

data = pd.read_csv('/content/stock data/sailstock.csv')

data['Date'] = pd.to_datetime(data['Date'])

data.set_index('Date', inplace=True)

print(data.head())

plt.figure(figsize=(10, 6))
plt.plot(data.index, data['Price'])
plt.title('Steel Stock Price Over Time')
plt.xlabel('Date')
plt.ylabel('Price')
plt.show()

train_size = int(len(data) * 0.8)
train, test = data.iloc[:train_size], data.iloc[train_size:]

model = ARIMA(train, order=(5,1,0)) # ARIMA(p,d,q) - You may need to tune these parameters
model_fit = model.fit()

print(model_fit.summary())

residuals = pd.DataFrame(model_fit.resid)
residuals.plot()
plt.title('ARIMA Model Residuals')
plt.show()

history = [x for x in train['Price']]
predictions = list()
for t in range(len(test)):
    model = ARIMA(history, order=(5,1,0))
    model_fit = model.fit()
    output = model_fit.forecast()
    yhat = output[0]
    predictions.append(yhat)
    obs = test['Price'].iloc[t]
    history.append(obs)
    print('predicted=%f, expected=%f' % (yhat, obs))

error = mean_squared_error(test['Price'], predictions, squared=False)
print('Test RMSE: %.3f' % error)

plt.figure(figsize=(10, 6))
plt.plot(test.index, test['Price'], label='Actual')
plt.plot(test.index, predictions, color='red', label='Predicted')
plt.title('Steel Stock Price Prediction')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

from sklearn.metrics import accuracy_score

# Convert price changes to binary classes (up or down)
test['Price_Class'] = np.where(test['Price'].diff().shift(-1) > 0, 1, 0)

# Calculate binary predictions
binary_predictions = [1 if pred > 0 else 0 for pred in predictions]

# Calculate accuracy
accuracy = accuracy_score(test['Price_Class'], binary_predictions)
print("Accuracy:", accuracy)

from sklearn.metrics import f1_score

# Calculate the F1 score
f1 = f1_score(test['Price_Class'], binary_predictions)

# Print the F1 score
print("F1 Score:", f1)